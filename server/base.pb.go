// Code generated by protoc-gen-go. DO NOT EDIT.
// source: base.proto

package server

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// импорт для подавления ошибок, если они не используются иным образом.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Проверка на совместимость с вашей версией protocolbuf
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// запрос поиска по автору
type RequestByAuthor struct {
	Like                 bool     `protobuf:"varint,1,opt,name=like,proto3" json:"like,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestByAuthor) Reset()         { *m = RequestByAuthor{} }
func (m *RequestByAuthor) String() string { return proto.CompactTextString(m) }
func (*RequestByAuthor) ProtoMessage()    {}
func (*RequestByAuthor) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{0}
}

func (m *RequestByAuthor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestByAuthor.Unmarshal(m, b)
}
func (m *RequestByAuthor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestByAuthor.Marshal(b, m, deterministic)
}
func (m *RequestByAuthor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestByAuthor.Merge(m, src)
}
func (m *RequestByAuthor) XXX_Size() int {
	return xxx_messageInfo_RequestByAuthor.Size(m)
}
func (m *RequestByAuthor) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestByAuthor.DiscardUnknown(m)
}

var xxx_messageInfo_RequestByAuthor proto.InternalMessageInfo

// Метод получения поле like в запросе поиска по автору
func (m *RequestByAuthor) GetLike() bool {
	if m != nil {
		return m.Like
	}
	return false
}

// Метод получения поле name в запросе поиска по автору
func (m *RequestByAuthor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// запрос поиска по книге
type RequestByBook struct {
	Like                 bool     `protobuf:"varint,1,opt,name=like,proto3" json:"like,omitempty"`
	Title                string   `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestByBook) Reset()         { *m = RequestByBook{} }
func (m *RequestByBook) String() string { return proto.CompactTextString(m) }
func (*RequestByBook) ProtoMessage()    {}
func (*RequestByBook) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{1}
}

func (m *RequestByBook) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestByBook.Unmarshal(m, b)
}
func (m *RequestByBook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestByBook.Marshal(b, m, deterministic)
}
func (m *RequestByBook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestByBook.Merge(m, src)
}
func (m *RequestByBook) XXX_Size() int {
	return xxx_messageInfo_RequestByBook.Size(m)
}
func (m *RequestByBook) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestByBook.DiscardUnknown(m)
}

var xxx_messageInfo_RequestByBook proto.InternalMessageInfo

// Метод получения поле like в запросе поиска по книге
func (m *RequestByBook) GetLike() bool {
	if m != nil {
		return m.Like
	}
	return false
}

// Метод получения поле title в запросе поиска по книге
func (m *RequestByBook) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}
// Ответ от сервера
type Response struct {
	Answer               string   `protobuf:"bytes,1,opt,name=answer,proto3" json:"answer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{2}
}

func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

// Метод получения поле answer из ответа сервера
func (m *Response) GetAnswer() string {
	if m != nil {
		return m.Answer
	}
	return ""
}

// регистрация запросов к серверу и ответа
func init() {
	proto.RegisterType((*RequestByAuthor)(nil), "server.RequestByAuthor")
	proto.RegisterType((*RequestByBook)(nil), "server.RequestByBook")
	proto.RegisterType((*Response)(nil), "server.Response")
}

// регистрация данных по proto файле 
func init() {
	proto.RegisterFile("base.proto", fileDescriptor_db1b6b0986796150)
}

var fileDescriptor_db1b6b0986796150 = []byte{
	// 203 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4a, 0x4a, 0x2c, 0x4e,
	0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x2b, 0x4e, 0x2d, 0x2a, 0x4b, 0x2d, 0x52, 0xb2,
	0xe4, 0xe2, 0x0f, 0x4a, 0x2d, 0x2c, 0x4d, 0x2d, 0x2e, 0x71, 0xaa, 0x74, 0x2c, 0x2d, 0xc9, 0xc8,
	0x2f, 0x12, 0x12, 0xe2, 0x62, 0xc9, 0xc9, 0xcc, 0x4e, 0x95, 0x60, 0x54, 0x60, 0xd4, 0xe0, 0x08,
	0x02, 0xb3, 0x41, 0x62, 0x79, 0x89, 0xb9, 0xa9, 0x12, 0x4c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x60,
	0xb6, 0x92, 0x25, 0x17, 0x2f, 0x5c, 0xab, 0x53, 0x7e, 0x7e, 0x36, 0x56, 0x8d, 0x22, 0x5c, 0xac,
	0x25, 0x99, 0x25, 0x39, 0x30, 0x9d, 0x10, 0x8e, 0x92, 0x12, 0x17, 0x47, 0x50, 0x6a, 0x71, 0x41,
	0x7e, 0x5e, 0x71, 0xaa, 0x90, 0x18, 0x17, 0x5b, 0x62, 0x5e, 0x71, 0x79, 0x6a, 0x11, 0x58, 0x1f,
	0x67, 0x10, 0x94, 0x67, 0xd4, 0xc0, 0xc8, 0xc5, 0xe2, 0x94, 0x58, 0x9c, 0x2a, 0x64, 0xcb, 0xc5,
	0x17, 0x9c, 0x9a, 0x58, 0x94, 0x9c, 0x01, 0x77, 0xa1, 0xb8, 0x1e, 0xc4, 0xf5, 0x7a, 0x68, 0x4e,
	0x97, 0x12, 0x40, 0x48, 0x40, 0x4c, 0x57, 0x62, 0x10, 0xb2, 0xe4, 0xe2, 0x81, 0x69, 0x07, 0xbb,
	0x52, 0x14, 0x43, 0x33, 0x48, 0x18, 0x9b, 0xd6, 0x24, 0x36, 0x70, 0x58, 0x19, 0x03, 0x02, 0x00,
	0x00, 0xff, 0xff, 0xf7, 0x30, 0xc1, 0x13, 0x39, 0x01, 0x00, 0x00,
}

// импорт для подавления ошибок, если они не используются иным образом.
var _ context.Context
var _ grpc.ClientConnInterface

// Проверка на совместимость с вашей версией пакета grpc
const _ = grpc.SupportPackageIsVersion6

// Интерфейс клиента
type BaseClient interface {
	SearchByAuthor(ctx context.Context, in *RequestByAuthor, opts ...grpc.CallOption) (*Response, error)
	SearchByBook(ctx context.Context, in *RequestByBook, opts ...grpc.CallOption) (*Response, error)
}

// grcp клиент 
type baseClient struct {
	cc grpc.ClientConnInterface
}

// создание клиента grcp
func NewBaseClient(cc grpc.ClientConnInterface) BaseClient {
	return &baseClient{cc}
}

// Метод запроса поиска по автору от клиента
func (c *baseClient) SearchByAuthor(ctx context.Context, in *RequestByAuthor, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/server.Base/SearchByAuthor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Метод запроса поиска по книге от клиента
func (c *baseClient) SearchByBook(ctx context.Context, in *RequestByBook, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/server.Base/SearchByBook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// интерфейс сервера
type BaseServer interface {
	SearchByAuthor(context.Context, *RequestByAuthor) (*Response, error)
	SearchByBook(context.Context, *RequestByBook) (*Response, error)
}
 
// Не реализованый сервер
type UnimplementedBaseServer struct {
}

// Не реализованый  метод запроса поиска по автору
func (*UnimplementedBaseServer) SearchByAuthor(ctx context.Context, req *RequestByAuthor) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchByAuthor not implemented")
}
// Не реализованый  метод запроса поиска по книге 
func (*UnimplementedBaseServer) SearchByBook(ctx context.Context, req *RequestByBook) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchByBook not implemented")
}

// Регистрация сервера
func RegisterBaseServer(s *grpc.Server, srv BaseServer) {
	s.RegisterService(&_Base_serviceDesc, srv)
}

// обработчик запроса поиска по автору
func _Base_SearchByAuthor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestByAuthor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseServer).SearchByAuthor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Base/SearchByAuthor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseServer).SearchByAuthor(ctx, req.(*RequestByAuthor))
	}
	return interceptor(ctx, in, info, handler)
}

// обработчик запроса поиска по книги
func _Base_SearchByBook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestByBook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseServer).SearchByBook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Base/SearchByBook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseServer).SearchByBook(ctx, req.(*RequestByBook))
	}
	return interceptor(ctx, in, info, handler)
}

var _Base_serviceDesc = grpc.ServiceDesc{
	ServiceName: "server.Base",
	HandlerType: (*BaseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchByAuthor",
			Handler:    _Base_SearchByAuthor_Handler,
		},
		{
			MethodName: "SearchByBook",
			Handler:    _Base_SearchByBook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "base.proto",
}
